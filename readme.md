## Dart однопоточный язык?

Часто в Dart сообществе, в статьях, а так же на собеседованиях можно встретить вопрос - является ли Dart однопоточным языком программирования (ЯП)?

Короткий ответ - да, но с оговорками.

Почему вообще принято считать Dart однопоточным ЯП?

В Dart создатели языка и его SDK - не заложили возможность напрямую взаимодействовать с потоками операционной системы (ОС), как например мы можем в C/C++/Java/C# и в многих других ЯП. Мы не можем создавать потоки ОС (~~Thread~~) и у нас отсутствуют примитивы синхронизации связанные с ними.

Так же асинхронная модель в Dart построена на применении цикла событий (Event Loop), который исполняется в одном потоке. Из за этого асинхронные события которые мы создаем в Dart исполняются в строгом порядке. Несколько раз запуская один и тот же асинхронный код мы получим строго один и тот же порядок исполнения, цикл событий в Dart в этом плане предсказуем, детерминиирован.

Но несмотря на это, в Dart есть механизмы для параллельного исполнения кода - изоляты, о которых мы сейчас поговорим.

Поэтому нельзя утверждать что Dart является однопоточным по той причине что в нем отсутствует возможность параллельного исполнения кода.

## Модель параллельного программирования в Dart

Сейчас мы с вами выяснили что в Dart отсутствует возможность создавать и управлять потоками ОС, отсутствуют примитивы синхронизации. Это означает что в Dart у нас не модель параллельного программирования с общей памятью.

Но при этом в Dart есть возможность для параллельного выполнения кода.

Какую тогда модель параллельного программирования использует Dart?

Dart использует акторную модель параллельного программирования.

Охарактеризовать ее можно следующим образом: в подобной модели у нас есть акторы, некоторые единицы/субъекты, каждый из которых исполняется независимо друг от друга. Они взаимодействуют с друг другом при помощи посылки имутабельных сообщений, адресные пространства (память) каждого из них независима от пространств других. Акторы обрабатывают сообщения асинхронно.

Подобная модель не была изобретена разработчиками Dart, она применяется и в других ЯП уже много лет. Пример ЯП которые поддерживают подобную модель "из коробки" - Erlang/Elixir/Swift/Scala/Ruby/JavaScript, а так же это ряд фреймворков в других языках Akka в Java, Akka.net в .NET, ряд C++ и Rust фреймворков и т.д.

Те из вас кто сталкивался с изолятами в Dart вероятно уже провели аналогии.

В Dart у нас акторы это изоляты, общение между изолятами происходит при помощи посылки сообщений через порты. Каждый из изолятов имеет свое собственное адресное пространство, собственный цикл событий (Event Loop), общение между изолятами происходит асинхронно.

В чем преимущества акторной модели?

Чтобы понять приемущества акторной модели, давайте поговорим о недостатка модели с общей памятью. 

При работе с потоками существует проблема синхронизации данных. Например, если мы будем использовать два потока которые работают с одними данными, при этом не используем механизмы синхронизации - мы можем получить следующее поведение. Два потока обращаются к одной переменной одновременно, далее записывают результат своей работы обратно, в результате мы получим некорректный результат.

Для синхронизации работы потоков используются различные механизмы синхронизации данных, например Mutex-ы/atomic_flag и т.д. Однако их использование тоже влечет за собой ряд проблем которые могут возникать при их использовании.

Одна из распространенных проблем при работе с потоками являются взаимные блокировки, они же так называемые deadlock-и. При использовании двух или более потоков работающих с общими данными через механизмы синхронизации могут возникать ситуации когда два потока используют данные, блокируют доступ к этим данным для других потоков. Однако для продолжения своей работы им необходимы данные потребляемые другими потоками. В этот момент выполнение работы потоков блокируется и они не могут продолжить свое выполнение.

Преимущества модели это простота параллельного выполнения кода, нам не нужно думать про синхронизацию работы с общей памятью, про взаимные блокировки (deadlock) и т.д. В этой модели можно написать код таким образом чтобы получить взаимное ожидание (взаимную блокировку/deadlock), но чтобы это получить нужно постараться.

Недостаток акторной модели очевиден.

Каждый из акторов имеет свое адресное пространство и передача сообщений происходит при помощи копирования сообщения из одной области памяти в другую. Тут есть потери по производительности.

У создателей Dart есть предложение по добавлению в Dart разделяемой памяти, один из вариантов как это будет реализовано это добавление в язык потоков ОС (Thread) и примитивов синхронизации (Mutex). Можете почитать про это на Github, перейдя по этому QR коду https://github.com/dart-lang/language/blob/main/working/333%20-%20shared%20memory%20multithreading/proposal.md. Не факт что это дойдет когда нибудь до релиза, но такие мысли у создателей языка появляются.

## Изолят

### Определения

Определения изолятов которые можно встретить в документации Dart и Flutter.

> Независимые исполнители, которые похожи на потоки, но не имеют общей памяти, общаются только с при помощи сообщений

> Изолированные контексты исполнения

### Dart VM

Давайте рассмотрим как устроены изоляты в Dart VM.

В Dart 2.15 было крупное изменение связанное с изолятами, у нас появились так называемые легковесные изоляты.

Вот так теперь выглядит схема Dart VM.

<div align="center">
  <img src="https://raw.githubusercontent.com/GlebBatykov/dart_isolate_lecture_2025/main/images/Dart%20VM.png" width="75%"/>
</div>

На схеме мы видим Heap, Heap с GC. Давайте сначала обсудим как устроена память в Dart.

Давайте вспомнить какие типы памяти вообще используются в программировании.

Стековая память представляет из себя структуру - стек, LIFO (last in/first out - последний пришел/первый вышел). Она используется для хренения информации об вызовах функций, а так же временных данных используемых в них. Данные хранимые в стековой памяти автоматически очищаются, после того как удаляются из стека. Стековая память выделяется и очищается очень быстро, однако имеет малый размер.

Поэтому есть второй тип памяти - динамическая память. Она уже в свою очередь не имеет таких жестких ограничений по объему. Объекты создаваемые там имеют неограниченный срок жизни, мы сами должны следить за их жизненным циклом. 

В Dart все объекты используемые нами создаются в динамической памяти, в куче. На предыдущей схеме вы могли заметить что в Dart VM есть 2 типа подобных областей памяти - с GC и без него. Давайте обсудим что же такое GC - он же Garbage Collector или сборщик мусора.

Что такое сборщик мусора?

Как мы уже сказали при использовании динамической памяти программисту нужно самостоятельно контролировать жизненный цикл создаваемых в ней объектов. Очищать память уничтожая объект когда он уже не нужен. Но программисты это люди, а людям свойственны ошибки, поэтому придумали такую вещь как сборщики мусора. Это механизмы которые позволяют автоматизировать освобождение памяти, снять с плеч программиста ответственность за это. Конечно их использование не проходит бесследно, каким бы хорошим не был сборщик мусора - скорее всего вручную память в той или иной ситуации можно очищать более эффективно. Так же использование сборщиком мусора накладывает некоторые накладные расходы и различные специфичные нюансы, по типу Stop the World эффекта о котором мы еще вспомним.

В Dart используется сборщик мусора с двумя поколениями объектов, "молодыми" объектами с коротким жизненным циклом и "старыми" объектам.

В Dart константы хранятся в Heap без GC, а все создаваемые нами объекты в runtime-е, то есть во время выполнения программы, создаются в Heap с GC. Для констант не нужен GC потому что у них нет жизненного цикла, они существуют все время выполнения программы.

В Dart VM у нас есть помимо изолятов так же понятие группы изолятов. Это понятие появилось в Dart 2.15, до этой версии его не существовало.

Ранее, до Dart 2.15 создание изолятов было тяжелой операцией, каждый отдельный изолят потреблял вплоть до нескольких Мб оперативной памяти. Передача сообщений между изолятами так же была гораздо медленней чем сейчас.

Разработчики смогли добиться улучшения производительности введя группы изолятов. Группа изолятов общий для нескольких изолятов контекст выполнения в Dart VM. Что это означает, ведь изоляты общей памяти у нас не имеют? Под общим контекстом подразумеваются различные служебные структуры внутри самого runtime-а, они переиспользуються для нескольких изолятов, что позволило сильно сократить время создания изолятов, оптимизировать скорость передачи сообщений между ними, а так же каждый новый изолят теперь дешевый по памяти. Технические все изоляты в одной группе используются одну и ту же кучу где хранят свои данные, однако это деталь реализации которая не видна для тех кто пишет Dart приложения.

Но так же это привело к изменению того как работает сборщик мусора (GC) в Dart. Ранее у каждого изоляты был собственный сборщик мусора, теперь сборщик мусора один для всей группы изолятов. Как говорят сами разработчики - в некоторых очень специфичных случаях этот момент может влиять на производительность приложений. Теперь приложения на Dart более подвержены Stop the World эффекту, когда работает сборщик мусора и все приложение приостанавливает свое выполнение в этот момент. Ранее сборщики мусора в разных изолятах работали независимо друг от друга. Но в случае с Dart, в области применения этого ЯП - это не критично.

Каждый изолят имеет собственный поток исполнения и цикл событий. Так же изолят помимо потока исполнения может быть связан и с другими потоками, например в случае приложением скомпилированном в JIT - у него будет поток связанный с JIT компиляцией.

Мы уже не однократно слышали о том что каждый из изолятов имеет собственный поток исполнения, однако это не означает что буквально для каждого созданного нами изолята в Dart VM будет создаваться отдельный поток ОС. В Dart VM есть пулы потоков, которые определенным образом распределяются между различными задачами в Dart VM, в том числе между изолятами.

Можно сказать что Dart VM будет распределять потоки из своего собственного пула между всеми изолятами, для того чтобы эффективно использовать ресурсы процессора.

Изоляты можно разделить на:

1. Main изолят
2. Worker изоляты
3. VM изоляты

Main изолят - это изолят из которого стартует наше Dart приложение, который запускает нашу функцию main. При его завершении - завершается Dart приложение.

Worker изоляты - это изолят которые мы создаем из нашего main изолята в процессе работы приложения. В случае завершения работы main изолята они тоже завершают свою работу.

VM изоляты - это изоляты внутри самой VM. Они в отличии от наших изолятов, могут ссылаться на области памяти других изолятов. А так же наши изоляты, под капотом, могут ссылаться на области памяти в VM изолятах. Например наши изоляты используют константные объекты, которые одни и те же для всех изолятов в приложении, вне зависимости от того в какой группе изолятов они находятся - это true/false объекты.

Мы упомянули сейчас константы, о том что объекты по типу true/false переиспользуються и лежат в некоторой области памяти внутри VM изолята, в которой под капотом наши изоляты обращаются напрямую.

Но что насчет наших констант, констант наших объектов которые мы создаем при написании приложений?

Константы у изолятов в одной группе изолятов - общие, поэтому для передачи сообщений между изолятами, по возможности, предпочтительно использовать константы. Например если вы передаете между изолятами какие то команды, не содержащие динамические данные, в этом случае использование констант улучшит производительность передачи сообщений между ними.

### Но как же Web?

Мы рассмотрели то как изоляты устроены в Dart VM, но что насчет Web? Ведь Dart умеет компилироваться в JavaScript и WASM.

Изолятов в Web-е нет, они есть только в Native Dart Runtime. Но в Web вместо них можно использовать JavaScript Web Workers. Web Workers в JavaScript сделаны так же с применением акторной модели, концептуально они очень похожи на изоляты, но имеют некоторые отличия.

## Изоляты в одной группе

Давайте теперь рассмотрим как мы можем создавать и работать с изолятами в рамках одной группы изолятов.

### Способы создания изолятов

Сущности для работы с изолятами в Dart SDK сконцентрированы в dart:isolate.

Для создания изолята мы можем использовать два static метода класса Isolate - run и spawn.

Метод run принимает FutureOr<T> Function(), так же у метода run есть не обязательный параметр debugName в котором мы можем указать идентификатор изолята который затем будет использоваться в DevTools и логах.

Этот метод запускает изолят в котором выполняется computation которую мы в него передали, далее мы получаем Future<T> из которой асинхронно мы получаем результат вычислений. После завершения вычислений изолят уничтожается.

Этот метод добавили в SDK не так давно, он является оберткой над Isolate.spawn. Мы используем его когда нам нужно выполнить какие то разовые вычисления и мы не заинтересованы в том чтобы у нас был долгоживующий изолят с которым мы работаем длительное время.

Давайте рассмотрим метод spawn. В отличии от метода run, он имеет более богатое API.

В метод spawn мы должны передать void Function(T), которая является точкой входа изолята который мы создаем, можно сказать что это будет функцией main созданного изолята.

Мы так же должны передать в него message типа T, это начальные данные которые получит изолят. Зачастую тут передается SendPort для рукопожатия с изолятом или какая то обертка над ним.

При помощи параметра paused мы можем создать изолят цикл события которого будет изначально приостановлен и затем самостоятельно в будущем запустить его. По умолчанию этот параметр равен false.

Параметр errorsAreFatal определяет что произойдет с изолятом при возникновении в нем необработанного исключения, в случае если он равен true - работа изолята будет завершена и мы получим из изолята сообщение с ошибкой (если подписаны на них). Если он равен false, то изолят продолжит свою работу и мы так же сможем получить из изолята сообщение с ошибкой. По умолчанию этот параметр равен true.

В параметре onExit мы можем указать SendPort в который будет отправлено сообщение после того как изолят завершит свою работу. По умолчанию сообщением будет являться null, однако можно указать и другое сообщение. Сделать это можно уже после создания изолята, при помощи вызова метода addOnExitListener у полученного при создании экземляра Isolate. В методе addOnExitListener котором можно указать SendPort и специфичный response. При помощи метода removeOnExitListener можно удалить зарегистрированного слушателя.

В параметре onError мы можем указать SendPort в который будет отправлено сообщение в случае если в изоляте будет необработанное исключение. Само сообщение представляет из себя List<dynamic> с двумя элементами, первый это сама ошибка, а второй элемент это StackTrace. Мы так же можем уже после создания изолята при помощи методов addErrorListener и removeErrorListener добавлять или удалять слушателей ошибок из изолята.

В этом методе у нас так же есть параметр debugName, при помощи которого можно задать идентификатор для изолята, который затем будет использоваться в DevTools, а так же логах.

### Обмен данных с изолятами

Мы уже неоднократно упоминали про то что изоляты обмениваются данными при помощи сообщений. При использовании Isolate.spawn мы сталкиваемся с необходимостью самостоятельно использовать Receive/Send порты.

Давайте рассмотрим что это такое и как мы можем обмениваться данными с изолятами.

Чтобы мы могли принимать сообщения от других изолятов мы должны создать ReceivePort - порт приема сообщений. Каждый ReceivePort имеет собственный SendPort который используется для отправки сообщений именно в этот ReceivePort.

ReceivePort имплементирует Stream, мы можем работать с ним как с потоком используя все специфичные для потока методы. По умолчанию ReceivePort не является широковещательным (broadcast) и у него может быть только один слушатель, однако мы можем использовать метод asBroadcastStream чтобы получить широковещательный поток.

При помощи getter-а sendPort у ReceivePort мы получаем его SendPort. У класса SendPort есть только один метод send для отправки сообщения.

При передаче сообщений есть ряд ограничений на типы данных которые мы можем передавать через порты. Эти ограничения разные в случае передачи данных между изолятами в рамках одной группы и в рамках разных групп.

Ограничения для одной группы изолятов:

1. ReceivePort - в отличии от SendPort, мы передать не можем;
2. Не можем пересылать объекты использующие нативные ресурсы, например Socket;
3. DynamicLibrary;
4. Finalizable;
5. Finalizer;
6. Pointer;
7. И все классы помеченные аннотацией @pragma('vm:isolate-unsendable').

Ограничения для разных групп изолятов:

1. Все ограничения что и для изолятов в одной группе;
2. Мы можем передавать только примитивы и типы которые есть в dart:core.

Как мы видим при передаче сообщений между изолятами в разных группах у нас действуют более жесткие ограничения. Поговорим об этом чуть позже в соответствующем разделе.

Хорошо, мы разобрались с тем что такое порты, а так же узнали о том какие данные мы можем передавать через них. Но как нам теперь их использовать?

Для того чтобы получить единичный ответ от другого изоляты, мы должны создать ReceivePort, передать изолят в качестве начального сообщения SendPort нашего ReceivePort. Далее когда нам будет нужно вернуть результат из изолята, в изоляте мы используем метод send у SendPort. В основном изоляте мы должны получить результат из ReceivePort.

Если нам нужно иметь долгоживущий изолят с которым мы должны иметь двухстороннюю связь - мы должны при создании изолята провести рукопожатие.

Мы создаем в основном изоляте ReceivePort, затем создаем изолят и передаем в него SendPort основного изолята. Затем в созданном изоляте создаем его ReceivePort и отправляем в SendPort основного изолята SendPort созданного изолята. Таким образом основной и созданный изолят будут знать про SendPort-ы друг друга и смогут обмениваться сообщениями.

В dart:isolate есть такая сущность как RawReceivePort, это более низкоуровневая сущность чем ReceivePort. В отличии от ReceivePort он не имплементирует Stream. Это обертка должна быть использована для осуществления рукопожатия между изолятами.

У RawReceivePort есть поле handler, в котором нужно объявлять логику обработки начального события из изолята, ожидается что первым событием будет сообщение содержащее SendPort этого изолята.

Так как у нас дважды вызвать методы listen у RawReceivePort (как и у ReceivePort), без преобразования его в широковещательный поток, не выйдет. То после приема начального сообщения и установки двухсторонней связи с изолятом мы можем превратить RawReceivePort в ReceivePort при помощи конструктора fromRawReceivePort у ReceivePort. И снова подписаться на полученный ReceivePort.

Открытый ReceivePort не позволяет изоляту завершить свою работу даже после того как у него заканчиваются события в Event Loop. Поэтому нужно не забывать закрывать ReceivePort-ы когда они уже не нужны.

### Способы завершения работы изолята

После создания изолята при помощи Isolate.spawn мы получаем экземпляр класса Isolate, через который мы можем завершить работу созданного изолята.

Для завершения работы необходимо использовать метод kill.

В методе kill есть один не обязательный параметр priority, типа int.

Есть две стратегии завершения изолята, вернее стратегии того как будет обработан изолятом наш запрос на его завершение:

1. immediate - выполнение текущего события в Event Loop-е изолята прерывается и наш запрос обработается. Равно 0;
2. beforeNextEvent - наш запрос добавляется в Event Loop изолята и выполнится тогда, когда до него дойдет очередь. Равно 1.

В поле priority мы можем самостоятельно указать 0 или 1, или воспользоваться константами Isolate.immediate/Isolate.beforeNextEvent.

### Обработка ошибок в изолятах

Когда мы создаем изоляты при помощи Isolate.run обработка ошибок ничем не отличается от обработки асинхронных ошибок в Dart. Тут разработчики уже все сделали за нас, они сами указывают onError параметр при создании изолята через Isolate.spawn, а так же они указывают errorsAreFatal - true. Далее в Future с результатом из Isolate.run мы получим ошибку которая произошла в изоляте.

Давайте рассмотрим как обрабатывать ошибки когда мы создаем изолят при помощи Isolate.spawn.

Как мы ранее подмечали при создании изолята при помощи Isolate.spawn мы можем передать SendPort в его параметр onError, а так же после создания воспользоваться методами addErrorListener и removeErrorListener для установки SendPort-а в который будут поступать ошибки из изолятов.

Так же у изолята есть errors поток, в котором можно прослушивать все ошибки возникающие в изоляте. Под капотом там так же используются методы addErrorListener и removeErrorListener, создается StreamController и RawReceivePort.

### Pause и resume

При помощи метода pause мы можем остановить цикл событий изолята. У этого метода есть один не обязательный параметр resumeCapability. Что такое Capability? Когда мы приостанавливаем или возобновляем изолят, мы можем создать экземпляр Capability и передавать его в методы pause и resume. Возобновить работу изолята при вызове метода resume - сможет только тот кто передаст Capability который ранее был передан в метод pause. Сделано это для того чтобы в случае если с изолятом мы работаем в нескольких местах приложения, мы ограничить возможность возобновления работы изолята и возобновлять его только из того места, из которого он был поставлен на паузу.

### Ping

У экземпляра изолята есть метод ping для проверки доступности изолята. В нем мы должны указать responsePort, это SendPort в который будет отправлен pong (ответ).

Мы можем указать какой ответ будет отправлен при помощи поля response, по умолчанию это null. Для response действуют такие же ограничения как и для любых других данных которые передаются между изолятами.

Так же для ping мы можем указать priority обработки этого события. Тут так же как мы уже смотрели для kill у нас есть две стратегии - immediate и beforeNextEvent.

### Создание изолята из другого изолята

Ранее когда мы создавали изоляты мы создавали изоляты исключительно из нашего основного изолята, однако мы можем создавать изоляты из других изолятов.

Для этого мы можем использовать такое же API, все работает идентично.

Таким образом мы можем создавать изоляты которые в свою очередь будут создавать и контролировать жизненный цикл уже других, нужных им изолятов.

При использовании таких цепочек из изолятов может быть затруднительно передавать SendPort-ы в каждый из изолятов в цепочке. Для регистрации SendPort-ов изолятов и осуществления доступа к ним из любого изолята можно воспользоваться пакетом [isolate_name_server](https://pub.dev/packages/isolate_name_server). В нем используется нативный код который хранит в себе SendPort-ы по ключу и из любого изолята у нас есть к ним доступ.

Эта функциональность есть в Flutter SDK. В пакете [isolate_name_server](https://api.flutter.dev/flutter/dart-ui/IsolateNameServer-class.html) реализация скопированна из Flutter.

#### Пулы изолятов

При необходимости мы можем использовать пулы из изолятов, создавать в пуле долгоживущие изоляты и распределять между ними какие то наши задачи.

Как и в других ЯП организуются пулы потоков, с расширением пула при необходимости, распределением задач между потоками, наличием различных стратегий для этого - аналогичные пулы можно организовывать и в Dart с изолятами.

Однако в Dart SDK готовых решений для этого нет.

Из популярных пакетов позволяющих организовывать подобное в сообществе есть [worker_manager](https://pub.dev/packages/worker_manager). Он так же умеет работать в Web-е используя JavaScropt Web Worker-ы.

## TransferableTypedData

В Dart SDK есть класс TransferableTypedData.

У этого класса достаточно не интуитивная документация и может быть не совсем понятно его предназначение. Если поискать информацию про него то в основном про него пишут следующее - он позволяет оптимизировать передачу больших наборов байт между изолятами.

Может показаться что он позволяет буквально передавать наборы байт между изолятами без их копирования. Или позволяет передавать наборы байт всегда за константное время.

Если почитать Github и заглянуть в исходники Dart SDK то мы видим следующее https://github.com/dart-lang/sdk/blob/main/sdk/lib/_internal/vm/lib/isolate_patch.dart#L739, https://github.com/dart-lang/sdk/blob/main/runtime/lib/isolate.cc#L1280, https://github.com/dart-lang/sdk/blob/main/runtime/lib/isolate.cc#L1344. 

Что мы там видим? При создании TransferableTypedData мы передаем в него исходный фиксированный типизированный набор байт, сразу при его создании выделяется буфер в который набор байт копируется. При этом процесс копирования тут с O(N) сложностью, чем больше исходный набор байт тем дольше будет операция создания буфера для TransferableTypedData. Далее в TransferableTypedData есть указатель на набор байт в созданном буфере. Сам объект TransferableTypedData передается между изолятами без копирования, за константное время. Далее в другом изоляте мы при помощи метода materialize можем получить копию исходного набора байт. При материализации мы можем быстро получить набор байт, потому что уже заранее мы создали копию исходного набора байт в буфере при создании TransferableTypedData. Изначально буфер создается в памяти текущей группы изолятов, однако после материализации переносится в область памяти изолята в котором был вызван метод materialize.

Метод materialize может быть вызван только один раз, повторный его вызов даже в другом изоляте - приведет к ошибке в runtime-е.

Так зачем тогда нужен TransferableTypedData, если в другом изоляте мы получаем копию объекта? Появление этой сущности связанно с проблемами при передаче типизированных массивов байт между изолятами, когда они проходили процесс сериализации. Поэтому появился отдельный тип с своей логикой передачи для таких задач. Так же тут у нас процесс создания копии исходного набора байт ложится на плечи того потока в котором мы создаем TransferableTypedData, а затем мы можем дешево достать из уже существующего буфера копию массива байт и работать с ней.

В некоторых случаях подобное может быть полезно с точки зреия оптимизации, например если мы в отдельном изоляте прочитали и как либо обработали большой набор байт, представим что это был видео файл. И хотим отправить его в основной изолят с UI, используя TransferableTypedData мы возлагаем на плечи worker изолята операцию по копированию набора байт, который затем быстро сможет использовать изолят с UI. То есть мы можем отделить дорогую операцию копирования большого набора байт, от того кто будет его в дальнейшем использовать в другом изоляте.

### Пример

Рассмотрим один пример в котором создадим TransferableTypedData и затем выполним materialize в другом изоляте.

### Можем ли мы передавать данные без копирования?

Ранее мы видели метод Isolate.exit, но не разобрали как он работает и зачем он нужен.

Очевидно он позволяет нам завершить работу текущего изолята из которого мы его вызываем. Однако в нем так же есть 2 не обязательных параметра.

Первый параметр finalMessagePort, это SendPort в который будет отправлено последнее сообщение после завершения работы этого изолята.

Второй парамер message, это произвольный объект который как раз и будет отправлен в указанный sendPort.

Уникальность этого метода состоит в том что мы можем ценой завершения изолята - передать из него объект без копирования за константное время. Так как изолят уничтожается, нам позволяют не копировать текущий объект (который был бы уничтожен), а передать его.

Это не работает если finalMessagePort является портом созданным в другой группе изолятов.

#### Других способов нет?

Есть еще один способ передать данные между изолятами без копирования. Это использование FFI. Мы можем разместить данные в нативе, далее передать другому изоляту указатель на эти данные - в виде числа (ведь Pointer передать мы не можем). Но в таком случае нам нужно так же позаботится о доступе к данным из разных потоков, например защитить при помощи Mutex-а. Ведь в каждом изоляте будет свой поток работающий с этими данными.

## Группы изолятов

Ранее мы говорили про изоляты созданные в рамках одной группы. Про изоляты в других группах вспоминали когда говорили про ограничения передачи данных через Receive/Send порты.

Давайте теперь подробнее рассмотрим как мы можем создавать изоляты в других группах и какие особенности они имеют.

Сразу стоит сказать что в Flutter приложениях мы не можем создавать другие группы изолятов, поэтому эта информация полезна в целом для понимания работы Dart VM. А так же при написании Dart, но не Flutter приложений.

Так же это может быть полезно при написании утилит на Dart, при помощи механизма создания изолятов в других группах можно творить "черную магию". 

Так же, в теории, это можно использовать для разбиения Dart приложений на модули/плагины, которые можно подключать к основному приложению без его перезапуска.

### Создание изолята в другой группе

Создать изолят в другой группе, а вернее создать другую группу изолятов - мы можем при помощи Isolate.spawnUri.

Когда мы создавали изоляты в рамках текущей группы при помощи Isolate.run и Isolate.spawn, мы указывали в качестве точки входа функцию. В случае Isolate.spawn эта функция так же принимала некоторое сообщение с данными которые мы указывали при создании изолята.

В отличии от них метод spawnUri ожидает от нас Uri. Ожидается что мы создадим группу изолятов из Dart library в которой у нас есть точка входа - функция main. Как раз из за этого для изолятов в других группах и действуют более жесткие ограничения на типы передаваемых данных, потому что гарантии того что в другой группе изолятов есть информация о том или ином типе данных может быть только в отношении примитивов, того что у нас есть в dart:core. Условно если у нас есть класс A в одной группе изолятов, то нет гарантий что в другой группе изолятов он будет, так как она запущена из другого исходного кода.

В зависимости от того какой тип компиляции использует наше Dart приложение в котором мы будем вызывать метод spawnUri - нам доступны разные варианты того в каком виде Dart library может быть представлена.

Для приложений использующих AOT компиляцию:

1. Aot-snapshot

Для приложений использующих JIT компиляцию:

1. Jit-snashot
2. Kernel-snapshot
3. Исходный код

Как мы уже подметили точкой входа для такого изолята служит функция main в запускаемой Dart library.

Мы привыкли что функция main может содержать, а может и не содержать список аргументов запуска типа List<String>. Однако так же функция main в Dart может содержать еще один параметр, типа dynamic. Этот параметр мы как раз можем передать в нее в методе spawnUri, например это может быть SendPort для установки связи между нашим изолятом и создаваемым нами изолятом в другой группе изолятов.

Поэтому функция main в Dart приложениях может следующий вид.

Без параметров.

```dart
void main() {
	// Some code
}
```

С одним параметром, аргументом.

```dart
void main(List<String> args) {
	// Some code
}
```

С двумя параметрами, аргументом и некоторыми данными, например SendPort-ом для связи с изолятом из которого был запущен этот код при помощи spawnUri.

```dart
void main(List<String> args, SendPort sendPort) {
	// Some code
}
```

Такую точку входа вы могли видеть например в сгенерированным build_runner-ом кодом, если заглянете в вашем проекте в файл .dart_tool -> build -> entrypoint -> build.dart.

Давайте теперь посмотрим на параметры метода spawnUri.

Этот метод имеет 3 обязательных параметра.

Первый это uri. В случае если мы используем запуск из snapshot-а это должен быть Uri с путем до файла snapshot-а, в случае если мы используем запуск из файла с исходным кодом это должен быть путь до .dart файла. В случае если мы используем запуск из исходного кода который мы генерируем в runtime-е, мы можем указать Uri следующим образом:

```dart
final String source = ...;

final uri = Uri.parse(
	'data:application/dart;charset=utf-8,$source',
);
```

Каждый из этих вариантов запуска мы рассмотрим чуть позже когда будем смотреть на примеры кода.

Далее у нас идет параметр args. Тут мы указываем аргументы которые затем будут переданы в функцию main создаваемого изолята, в соответствующий параметр.

Далее идет параметр message типа dynamic. То что мы укажем здесь как раз и будет передано в второй аргумент функции main создаваемого изолята.

На те данные которые мы передаем в args и message действуют ограничения на передачу данных между изолятами в разных группах.

Тут у нас так же есть параметры paused, onExit, onError, errorsAreFatal, debugName - такие же как и в Isolate.spawn, мы уже обсуждали их ранее.

Параметр chacked использовался до Dart 2, когда вышла строгая система типов. Ранее он влиял на то будет ли запущена проверка типов для кода который мы запускаем при помощи spawnUri, а так же на проверку assert-ов. Сейчас этот параметр может влиять только на проверку assert-ов. В production окружении assert-ы по прежнему будут отключены. Параметр на данный момент мало актуален.

В параметре environment мы можем указать данные которые затем будут доступны в запущенном коде через Platform.environment или например String.fromEnvironment.

Параметр packageRoot устарел.

Параметры packageConfig и automaticPackageResolution используются для указания того как будет искаться pubspec.yaml файл для кода который мы запускаем. Это актуально когда мы создаем группу изолятов из исходного кода в JIT компиляции. Ведь исходный код может и скорее всего будет содержать зависимости и компилятору нужно будет понять откуда их брать. По умолчанию параметр automaticPackageResolution равен false.

Как мы уже сказали ранее в Flutter приложениях использовать spawnUri мы не можем. Тогда для чего нам может пригодится это?

Запуск кода через spawnUri используется различными утилитами, как я уже говорил в сгенерированном коде build_runner-а можно найти то что у них генерируется точка входа которая подключает все созданные builder-ы. Затем кем то запускается и через SendPort из нее получают результат.

То есть это потенциально очень полезная вещь для написания каких то утилит, которые могут брать куски логики написанной на Dart, в виде просто отдельных классов или методов, затем запускать эту логику через spawnUri и получать от туда результат.

Так же это может быть использовано для создания Dart приложений с модульной архитектурой, в которой какие то ее части были бы реализованы в виде модулей/плагинов. Эти модули подключались бы при помощи spawnUri без необходимости перекомпилировать/перезапускать основное приложение.

Можно так же генерировать исходный код из которого будет запущен изолят прямо налету в runtime-е или даже представить ситуацию при которой у нас был бы сервер на Dart на который можно было бы загружать произвольный исходный код.

## Flutter

Давайте теперь поговорим про Flutter. Какие есть отличительные особенности при работе с изолятыми в нем.

### Compute

Вероятно большинство кто писал Flutter приложения, даже если не использовал изоляты напрямую - знают про функцию compute.

Для Native платформ она в данный момент является оберткой над Isolate.run. А для Web-а она запустит вычисления в том же цикле событий, поддержки JavaScript Web Workers из коробки для Web тут нет.

### PlatformChannels и изоляты

До Flutter 3.7 у нас была проблема с работой PlatfromChannels в любом изоляте кроме основного - они не работали. Соответственно было невозможно вынести задачи которые должны были взаимодействовать с нативом через платформенные каналы Flutter-а.

В сообществе был пакет [flutter_isolate](https://pub.dev/packages/flutter_isolate) который позволял это делать. Однако он предоставлял "костыль", для каждого такого изолята в котором он позволял использовать каналы платформы он создавал отдельный экземпляр Flutter Engine. Что нельзя конечно назвать оптимальным решением.

В версии 3.7 разработчики Flutter добавили возможность подключать наши отдельные изоляты к нашему одному экземпляру Flutter Engine при помощи BackgroundIsolateBinnaryMessanger.

Чтобы подключить наш изолят к Flutter Engine мы должны получить RootIsolateToken из getter-а RootIsolateToken.instance в нашем основном (root) изоляте. Далее мы передаем его в изолят который создаем, далее вызваем метод BackgroundIsolateBinaryMessenger.ensureInitialized и передаем в него токен.

После этого мы можем использовать каналы платформы в этом изоляте.

Мы не можем устанавливать двухсторонюю связь при помощи BackgroundIsolateBinaryMessenger. Связь только в одну сторону.

## FFI и изоляты

При использовании FFI в отдельном изоляте стоит помнить что Dart не предоставляет гарантий что изолят будет использовать один и тот же поток. В процессе существования изолята не закрепляется один и тот же поток и пула потоков Dart VM, в разные моменты времени различные потоки из пула могут заходить в изолят и исполнять код в нем. Следовательно механизмы/структуры которые привязаны к одному конкретному потоку, например в котором они были созданы, корректно работать не будут. Такая гарантия у нас есть только в основном изоляте, из него мы можем безопасно работать в FFI с такими механизмами.

При помощи FFI мы можем вызвать функции и получать результаты. Но так же мы можем при помощи SendPort-ов принимать асинхронные сообщения, ответы от нативного кода. 

Для этого существуют такие сущности в dart:ffi и NativePort, NativeCallable. В рамках этой лекции разбирать примеры с FFI мы не будем, однако тут я закреплю полезные ссылки на примеры и документацию, которые можно посмотреть если вас интересуют подробности.

Мы ранее в этой лекции разбирали такую сущность как TransferableTypedData, как мы уже сказали она не позволяет буквально без копирования данных передавать данные между изолятами. Однако сами разработчики Dart на Github подсказали что в данный момент для подобного можно использовать FFI. Вы можете создать какую то структуру, какие то данные в нативном коде через FFI, затем передавать между изолятами указатель на эти данные в виде int числа и работать с этими данными из нескольких изолятов. Однако в этом варианте нужно будет предусмотреть в нативном коде механизм синхронизации, ведь у каждого из изолятов будет собственный поток работающий с этими данными.

## Рекомендации

Одной из распространенных ошибок при использовании изолятов - забыть закрыть ReceivePort. Открытый ReceivePort не позволяет изоляту завершить свою работу, даже после того как в его Event Loop-е заканчиваются события.

Далее нужно не забывать уничтожать изоляты, когда они нам больше не нужны, тем самым освобождая память выделяемую под них. Нужно так же при создании изолята отдавать себе отчет насколько часто нам нужно выполнять себе что то в изоляте - нам нужен долгоживущий изолят (для множества операций) или мы можем создать его через Isolate.run (мы редко используем изолят и можем создавать/уничтожать его для каждого вычисления).

При использовании изолятов нужно не забывать про концепцию памяти, у них нет общей памяти и глобальные переменные для каждого изолята будут свои. Нужно и помнить про константы, константы у изолятов в рамках одной группы одни. Если вам нужно передавать между изолятами какие то события без динамических данных - используйте константы для оптимизации передачи данных между изолятами.

При использовании изолятов через Isolate.spawn и Isolate.spawnUri не забывайте обрабатывать ошибки возникающие в них, не забывайте что можете получать ошибки из изолятов, не игнорируйте это.

Если вы используете пул изолятов, то нет смысла создавать пул слишком большого размера. Чаще всего будет оптимально создать пул равный Platform.numberOfProcessors. Используя больше изолятов чем ядер вашего ЦП вы не получите прибавку к производительности, не сможете ускорить задачу еще сильнее, а скорее потеряете в производительности из за необходимости потокам часто переключаться между контекстами заходя в разные изоляты.
